// Generated by CoffeeScript 1.7.1
(function() {
  var body, collide, debug, force_g, force_g_offsetX, force_g_offsetY, init_pop_data, init_power_data, label_container, log, max_size, min_size, pack_g, pack_g_offsetX, pack_g_offsetY, pop_format, power_format, power_scale, rotate, svg;

  debug = true;

  log = debug ? console.log.bind(console) : function() {};

  min_size = 1;

  max_size = 300;

  force_g_offsetX = 100;

  force_g_offsetY = 200;

  pack_g_offsetX = 600;

  pack_g_offsetY = 200;

  pop_format = d3.format(".3s");

  power_format = d3.format(".0f");

  power_scale = d3.scale.pow().exponent(0.25).domain([0, 3000]).range([min_size, max_size / 3]);

  body = d3.select("body");

  svg = d3.select("svg");

  force_g = svg.append("g").attr("transform", "translate(" + force_g_offsetX + ", " + force_g_offsetY + ")");

  pack_g = svg.append("g").attr("transform", "translate(" + pack_g_offsetX + ", " + pack_g_offsetY + ")");

  label_container = d3.select(".container").append("div").attr("class", "label-container");

  d3.json("data.json", function(err, data) {
    var cur_depth, cur_stage, force, force_data, force_labels, force_nodes, pack, pack_data, pack_nodes, pop_data, pop_label_links, pop_label_links_data, pop_labels, power_data, update, update_force_node, update_pack_node;
    power_data = init_power_data(data);
    pop_data = init_pop_data(data);
    log(power_data);
    log(pop_data);
    pack = d3.layout.pack().size([max_size, max_size]);
    pack_data = pack.nodes(pop_data).filter(function(d) {
      return !d.hidden;
    }).reverse();
    pack_g.datum(pack_data);
    pack_nodes = pack_g.selectAll(".pack.node").data(pack_data).enter().append("g").attr("transform", function(d) {
      var cpoint, pt;
      cpoint = {
        x: max_size / 2,
        y: max_size / 2
      };
      pt = rotate(d, cpoint, -Math.PI / 2);
      d.pack_x = pt.x;
      d.pack_y = pt.y;
      return "translate(" + d.pack_x + ", " + d.pack_y + ")";
    }).attr("id", function(d) {
      return "pack-" + d.id;
    }).attr("class", function(d) {
      return "pack node " + d.id;
    });
    pack_nodes.append("circle").attr("r", function(d) {
      return d.r;
    });
    pop_labels = label_container.selectAll(".pack.label").data(pack_data).enter().append("div").attr("class", function(d) {
      return "pack label " + d.id;
    }).attr("id", function(d) {
      return "label-" + d.id;
    }).style("top", function(d) {
      return d.label_top = pack_g_offsetY + d.pack_y - d.r;
    }).style("left", function(d) {
      return d.label_left = pack_g_offsetX + d.pack_x - d.r;
    }).style("width", function(d) {
      return d.label_width = d.r * 2;
    }).style("height", function(d) {
      return d.label_height = d.r * 2;
    });
    pop_labels.append("p").html(function(d) {
      return "<strong>" + d.name + "</strong> " + (pop_format(d.value));
    });
    pop_label_links_data = pack_data.filter(function(d) {
      return d.label_pos;
    });
    pop_label_links = pack_g.selectAll("line.label-link").data(pop_label_links_data).enter().append("line").attr("class", "label-link").attr("x1", function(d) {
      return d.pack_x;
    }).attr("y1", function(d) {
      return d.pack_y;
    }).attr("x2", function(d) {
      var offset;
      offset = d.label_pos.x > 0 ? 0 : 100;
      return d.label_left + d.label_pos.x - pack_g_offsetX + offset;
    }).attr("y2", function(d) {
      return d.label_top + d.label_pos.y - pack_g_offsetY + 100 / 2;
    });
    force_data = [];
    force_nodes = force_g.selectAll(".force.node").data(force_data, function(d) {
      return d.id;
    });
    force_labels = label_container.selectAll(".power.label").data(force_data);
    force = d3.layout.force().gravity(0.05).size([300, 300]).charge(0).friction(0.3).on("tick", function(e) {
      force_nodes.each(collide(e.alpha, force_data)).attr("transform", function(d) {
        return "translate(" + d.x + ", " + d.y + ")";
      });
      return force_labels.style("-webkit-transform", function(d) {
        var width_offset, x, y;
        width_offset = parseFloat(this.style.width) === 100 ? -50 + d.r : 0;
        x = d.x + force_g_offsetX - d.r + width_offset;
        y = d.y + force_g_offsetY - d.r;
        return "translate3d(" + x + "px, " + y + "px, 0px)";
      });
    });
    update_force_node = function() {
      force_nodes = force_g.selectAll(".force.node").data(force_data, function(d) {
        return d.id;
      });
      force_nodes.select("circle").transition().duration(1000).tween('force_r', function(d) {
        var i;
        console.log("changed", d.id);
        i = d3.interpolate(this.getAttribute("r") || 0, power_scale(d.value));
        return function(t) {
          d.r = i(t);
          return this.setAttribute("r", d.r);
        };
      });
      force_nodes.enter().append("g").attr("class", "force node").append("circle").attr("id", function(d) {
        return d.id;
      }).transition().duration(1000).tween('force_r_enter', function(d) {
        var i;
        console.log("added", d.id);
        i = d3.interpolate(this.getAttribute("r") || 0, power_scale(d.value));
        return function(t) {
          d.r = i(t);
          return this.setAttribute("r", d.r);
        };
      });
      force_nodes.exit().select("circle").transition().duration(1000).tween('force_r_exit', function(d) {
        var i;
        console.log("removed", d.id);
        i = d3.interpolate(d.r || 0, 0);
        return function(t) {
          d.r = i(t);
          return this.setAttribute("r", d.r);
        };
      }).each("end", function() {
        return this.parentNode.remove();
      });
      force_labels = label_container.selectAll(".power.label").data(force_data, function(d) {
        return d.id;
      });
      force_labels.attr("class", function(d) {
        return "power label " + d.id;
      }).attr("id", function(d) {
        return "label-" + d.id;
      }).style("width", function(d) {
        return Math.max(power_scale(d.value) * 2, 100);
      }).style("height", function(d) {
        return power_scale(d.value) * 2;
      }).select("p").html(function(d) {
        return "<strong>" + d.name + "</strong> " + (power_format(d.value)) + "x";
      }).style("opacity", 0).transition().duration(1000).style("opacity", 1);
      force_labels.enter().append("div").attr("class", function(d) {
        return "power label " + d.id;
      }).attr("id", function(d) {
        return "label-" + d.id;
      }).style("width", function(d) {
        return Math.max(power_scale(d.value) * 2, 100);
      }).style("height", function(d) {
        return power_scale(d.value) * 2;
      }).append("p").html(function(d) {
        return "<strong>" + d.name + "</strong> " + (power_format(d.value)) + "x";
      }).style("opacity", 0).transition().duration(1000).style("opacity", 1);
      force_labels.exit().transition().duration(1000).style("opacity", 0).remove();
      force.nodes(force_data).start();
      return force_nodes.call(force.drag);
    };
    update_pack_node = function(depth) {
      pack_nodes.select("circle").filter(function(d) {
        return d.depth !== depth;
      }).transition().style("fill", "none");
      pack_nodes.select("circle").filter(function(d) {
        return d.depth === depth;
      }).style("fill", "").transition().style("opacity", 1);
      pop_labels.style("opacity", 0).filter(function(d) {
        return d.depth === depth || (depth >= 2 && d.id === "others");
      }).transition().duration(1000).style("opacity", 1);
      pop_label_links.style("opacity", 0).filter(function(d) {
        return d.depth === depth;
      }).transition().duration(1000).style("opacity", 1);
      return pop_labels.filter(function(d) {
        return d.depth === depth && d.label_pos;
      }).style("width", 100).style("height", 100).style("top", function(d) {
        return d.label_top + d.label_pos.y;
      }).style("left", function(d) {
        return d.label_left + d.label_pos.x;
      });
    };
    cur_stage = "";
    cur_depth = 0;
    update = function(stage, depth) {
      var last_force_data;
      if (stage === cur_stage) {
        return;
      }
      force_data = power_data[stage];
      last_force_data = power_data[cur_stage];
      if (last_force_data) {
        force_data.forEach(function(d) {
          var match_nodes;
          match_nodes = last_force_data.filter(function(e) {
            return d.id === e.id;
          });
          if (match_nodes[0]) {
            d.x = match_nodes[0].x;
            return d.y = match_nodes[0].y;
          }
        });
      }
      update_force_node();
      update_pack_node(depth);
      cur_stage = stage;
      cur_depth = depth;
      return log(cur_stage, cur_depth);
    };
    update("stage1", 0);
    d3.select("button#stage1").on("click", function() {
      return update("stage1", 0);
    });
    d3.select("button#stage2").on("click", function() {
      return update("stage2", 1);
    });
    d3.select("button#stage3").on("click", function() {
      return update("stage3", 2);
    });
    return d3.select("button#stage4").on("click", function() {
      return update("stage4", 3);
    });
  });

  init_power_data = function(data) {
    var ec_voter, ec_voter_power, nodes, power_data, sectors_length, stage_name;
    ec_voter = data.election_comittee.voter;
    ec_voter_power = data.registered_voter / ec_voter;
    sectors_length = data.election_comittee.sectors.length;
    power_data = {
      stage1: [
        {
          id: "all",
          name: "Registered Voters",
          value: 1
        }
      ],
      stage2: [
        {
          id: "all",
          name: "Others",
          value: 0
        }, {
          id: "ec-voters",
          name: "Voters for Election Comittee",
          value: data.registered_voter / ec_voter
        }
      ],
      stage3: [
        {
          id: "all",
          name: "Others",
          value: 0
        }
      ],
      stage4: [
        {
          id: "all",
          name: "Others",
          value: 0
        }
      ]
    };
    data.election_comittee.sectors.forEach(function(sector) {
      power_data.stage3.push({
        id: sector.id,
        name: sector.name,
        value: (ec_voter / sectors_length) / sector.count * ec_voter_power
      });
      return power_data.stage4.push({
        id: sector.id,
        name: "Voted-in Election Comittee Members from " + sector.name,
        value: data.registered_voter / (data.election_comittee.seats_per_sector * sectors_length)
      });
    });
    for (stage_name in power_data) {
      nodes = power_data[stage_name];
      nodes.forEach(function(d) {
        return d.r = power_scale(d.value);
      });
    }
    return power_data;
  };

  init_pop_data = function(data) {
    var ec_voter, label_pos, pop_data;
    ec_voter = data.election_comittee.voter;
    label_pos = {
      "sector-lrw": {
        x: -120,
        y: -50
      },
      "sector-fhit": {
        x: -110,
        y: -20
      },
      "sector-hkcpb": {
        x: -130,
        y: 20
      },
      "sector-ehil": {
        x: 85,
        y: 10
      },
      "sector-lrw-cm": {
        x: -130,
        y: -125
      },
      "sector-fhit-cm": {
        x: -130,
        y: -70
      },
      "sector-hkcpb-cm": {
        x: -120,
        y: 10
      },
      "sector-ehil-cm": {
        x: 65,
        y: -45
      }
    };
    pop_data = {
      id: "all",
      name: "Registered Voter",
      value: data.registered_voter,
      children: [
        {
          id: "others",
          name: "Others",
          value: data.registered_voter - ec_voter
        }, {
          id: "ec-voters",
          name: "Voters for Election Comittee",
          value: ec_voter,
          children: []
        }
      ]
    };
    pop_data.children[1].children = data.election_comittee.sectors.map(function(sector) {
      return {
        id: sector.id,
        name: sector.name,
        value: sector.count,
        label_pos: label_pos[sector.id],
        children: [
          {
            id: "" + sector.id + "-cm",
            name: "Voted-in Election Comittee Members from " + sector.name,
            value: data.election_comittee.seats_per_sector,
            label_pos: label_pos["" + sector.id + "-cm"]
          }, {
            id: "" + sector.id + "-non-cm",
            name: "Election Comittee Non-members from " + sector.name,
            value: sector.count - data.election_comittee.seats_per_sector,
            hidden: true
          }
        ]
      };
    });
    return pop_data;
  };

  rotate = function(point, cpoint, angle) {
    var c, s, x, y;
    s = Math.sin(angle);
    c = Math.cos(angle);
    x = point.x - cpoint.x;
    y = point.y - cpoint.y;
    return {
      x: cpoint.x + x * c - y * s,
      y: cpoint.y + x * s + y * c
    };
  };

  collide = function(alpha, force_data) {
    var quadtree;
    alpha = alpha * 0.3;
    quadtree = d3.geom.quadtree(force_data);
    return function(d) {
      var nx1, nx2, ny1, ny2, padding, r;
      padding = 40;
      r = d.r + padding;
      nx1 = d.x - r;
      nx2 = d.x + r;
      ny1 = d.y - r;
      ny2 = d.y + r;
      return quadtree.visit(function(quad, x1, y1, x2, y2) {
        var l, x, y;
        if (quad.point && (quad.point !== d)) {
          x = d.x - quad.point.x;
          y = d.y - quad.point.y;
          l = Math.sqrt(x * x + y * y);
          r = d.r + quad.point.r + padding;
          if (l < r) {
            l = (l - r) / l * alpha;
            d.x -= x *= l;
            d.y -= y *= l;
            quad.point.x += x;
            quad.point.y += y;
          }
        }
        return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
      });
    };
  };

}).call(this);

//# sourceMappingURL=main3.map
