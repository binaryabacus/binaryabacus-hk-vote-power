// Generated by CoffeeScript 1.7.1
(function() {
  var body, collide, debug, force_g, force_g_offsetX, force_g_offsetY, init_pop_data, init_power_data, log, max_size, min_size, pack_g, pack_g_offsetX, pack_g_offsetY, power_scale, rotate, svg;

  debug = true;

  log = debug ? console.log.bind(console) : function() {};

  min_size = 1;

  max_size = 300;

  force_g_offsetX = 100;

  force_g_offsetY = 200;

  pack_g_offsetX = 600;

  pack_g_offsetY = 200;

  power_scale = d3.scale.pow().exponent(0.25).domain([0, 3000]).range([min_size, max_size / 3]);

  body = d3.select("body");

  svg = d3.select("svg");

  force_g = svg.append("g").attr("transform", "translate(" + force_g_offsetX + ", " + force_g_offsetY + ")");

  pack_g = svg.append("g").attr("transform", "translate(" + pack_g_offsetX + ", " + pack_g_offsetY + ")");

  d3.json("data.json", function(err, data) {
    var cur_stage, force, force_data, force_nodes, pack, pack_data, pack_nodes, pop_data, power_data, update, update_force_node;
    power_data = init_power_data(data);
    pop_data = init_pop_data(data);
    log(power_data);
    log(pop_data);
    pack = d3.layout.pack().size([max_size, max_size]);
    pack_data = pack.nodes(pop_data).filter(function(d) {
      return !d.hidden;
    });
    pack_g.datum(pack_data);
    pack_nodes = pack_g.selectAll(".pack.node").data(pack_data).enter().append("g").attr("transform", function(d) {
      var cpoint, pt;
      cpoint = {
        x: max_size / 2,
        y: max_size / 2
      };
      pt = rotate(d, cpoint, -Math.PI / 2);
      d.pack_x = pt.x;
      d.pack_y = pt.y;
      return "translate(" + d.pack_x + ", " + d.pack_y + ")";
    }).attr("id", function(d) {
      return "pack-" + d.id;
    }).attr("class", function(d) {
      return "pack node " + d.id;
    });
    pack_nodes.append("circle").attr("r", function(d) {
      return d.r;
    });
    force_data = [];
    force_nodes = force_g.selectAll(".force.node").data(force_data, function(d) {
      return d.id;
    });
    force = d3.layout.force().gravity(0.05).size([300, 300]).charge(0).on("tick", function(e) {
      return force_nodes.each(collide(e.alpha, force_data)).attr("transform", function(d) {
        return "translate(" + d.x + ", " + d.y + ")";
      });
    });
    update_force_node = function() {
      force_nodes = force_g.selectAll(".force.node").data(force_data);
      force_nodes.transition().duration(1000).select("circle").attr("r", function(d) {
        return power_scale(d.value);
      });
      force_nodes.enter().append("g").attr("class", "force node").append("circle").attr("r", 0).attr("id", function(d) {
        return d.id;
      }).transition().duration(1000).attr("r", function(d) {
        return d.r;
      });
      force_nodes.exit().select("circle").transition().duration(1000).attr("r", 0).each("end", function() {
        return this.parentNode.remove();
      });
      return force.nodes(force_data).start();
    };
    cur_stage = "";
    update = function(stage) {
      if (stage === cur_stage) {
        return;
      }
      cur_stage = stage;
      log(cur_stage);
      force_data = power_data[cur_stage];
      return update_force_node();
    };
    update("stage1");
    d3.select("button#stage1").on("click", function() {
      return update("stage1");
    });
    d3.select("button#stage2").on("click", function() {
      return update("stage2");
    });
    d3.select("button#stage3").on("click", function() {
      return update("stage3");
    });
    return d3.select("button#stage4").on("click", function() {
      return update("stage4");
    });
  });

  init_power_data = function(data) {
    var ec_voter, ec_voter_power, nodes, power_data, sectors_length, stage_name;
    ec_voter = data.election_comittee.voter;
    ec_voter_power = data.registered_voter / ec_voter;
    sectors_length = data.election_comittee.sectors.length;
    power_data = {
      stage1: [
        {
          id: "all",
          name: "Registered Voters",
          value: 1
        }
      ],
      stage2: [
        {
          id: "all",
          name: "Others",
          value: 0
        }, {
          id: "ec-voters",
          name: "Voters for Election Comittee",
          value: data.registered_voter / ec_voter
        }
      ],
      stage3: [
        {
          id: "all",
          name: "Others",
          value: 0
        }
      ],
      stage4: [
        {
          id: "all",
          name: "Others",
          value: 0
        }
      ]
    };
    data.election_comittee.sectors.forEach(function(sector) {
      power_data.stage3.push({
        id: sector.id,
        name: sector.name,
        value: (ec_voter / sectors_length) / sector.count * ec_voter_power
      });
      return power_data.stage4.push({
        id: sector.id,
        name: "Voted-in Election Comittee Members from " + sector.name,
        value: data.registered_voter / (data.election_comittee.seats_per_sector * sectors_length)
      });
    });
    for (stage_name in power_data) {
      nodes = power_data[stage_name];
      nodes.forEach(function(d) {
        return d.r = power_scale(d.value);
      });
    }
    return power_data;
  };

  init_pop_data = function(data) {
    var ec_voter, pop_data;
    ec_voter = data.election_comittee.voter;
    pop_data = {
      id: "all",
      name: "Registered Voter",
      value: data.registered_voter,
      children: [
        {
          id: "others",
          name: "Others",
          value: data.registered_voter - ec_voter
        }, {
          id: "ec-voters",
          name: "Voters for Election Comittee",
          value: ec_voter,
          children: []
        }
      ]
    };
    pop_data.children[1].children = data.election_comittee.sectors.map(function(sector) {
      return {
        id: sector.id,
        name: sector.name,
        value: sector.count,
        children: [
          {
            id: "" + sector.id + "-cm",
            name: "Voted-in Election Comittee Members from " + sector.name,
            value: data.election_comittee.seats_per_sector
          }, {
            id: "" + sector.id + "-non-cm",
            name: "Election Comittee Non-members from " + sector.name,
            value: sector.count - data.election_comittee.seats_per_sector,
            hidden: true
          }
        ]
      };
    });
    return pop_data;
  };

  rotate = function(point, cpoint, angle) {
    var c, s, x, y;
    s = Math.sin(angle);
    c = Math.cos(angle);
    x = point.x - cpoint.x;
    y = point.y - cpoint.y;
    return {
      x: cpoint.x + x * c - y * s,
      y: cpoint.y + x * s + y * c
    };
  };

  collide = function(alpha, force_data) {
    var quadtree;
    alpha = alpha * 0.25;
    debugger;
    quadtree = d3.geom.quadtree(force_data);
    return function(d) {
      var nx1, nx2, ny1, ny2, padding, r;
      padding = 20;
      r = d.r + padding;
      nx1 = d.x - r;
      nx2 = d.x + r;
      ny1 = d.y - r;
      ny2 = d.y + r;
      return quadtree.visit(function(quad, x1, y1, x2, y2) {
        var l, x, y;
        if (quad.point && (quad.point !== d)) {
          debugger;
          x = d.x - quad.point.x;
          y = d.y - quad.point.y;
          l = Math.sqrt(x * x + y * y);
          r = d.r + quad.point.r + padding;
          if (l < r) {
            l = (l - r) / l * alpha;
            d.x -= x *= l;
            d.y -= y *= l;
            quad.point.x += x;
            quad.point.y += y;
          }
        }
        return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
      });
    };
  };

}).call(this);

//# sourceMappingURL=main3.map
