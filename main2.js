// Generated by CoffeeScript 1.7.1
(function() {
  var body, charge_scale, circle_fill, collide, debug, force_g, force_g_offsetX, force_g_offsetY, label_container, log, max_size, min_size, pack_g, pack_g_offsetX, pack_g_offsetY, pop_format, power_format, power_scale, random, rotate, stroke_fill, svg, wrap;

  debug = true;

  log = debug ? console.log.bind(console) : function() {};

  body = d3.select("body");

  svg = d3.select("svg");

  min_size = 1;

  max_size = 300;

  circle_fill = "#f4f4f4";

  stroke_fill = "#DDDBDB";

  force_g_offsetX = 100;

  force_g_offsetY = 200;

  pack_g_offsetX = 600;

  pack_g_offsetY = 200;

  pop_format = d3.format(".3s");

  power_scale = d3.scale.pow().exponent(0.25).domain([0, 3000]).range([min_size, max_size / 3]);

  charge_scale = d3.scale.log().clamp(true).domain([0, max_size / 2]).range([0, 300]);

  power_format = d3.format(".0f");

  force_g = svg.append("g").attr("transform", "translate(" + force_g_offsetX + ", " + force_g_offsetY + ")");

  pack_g = svg.append("g").attr("transform", "translate(" + pack_g_offsetX + ", " + pack_g_offsetY + ")");

  label_container = d3.select(".container").append("div").attr("class", "label-container");

  d3.json("data.json", function(err, data) {
    var cur_stage, ec_voter, ec_voter_power, force, force_data, force_labels, force_nodes, get_style, pack, pack_data, pack_root, pop_labels, pop_nodes, sectors_length, stage_style, update;
    ec_voter = data.election_comittee.voter;
    ec_voter_power = data.registered_voter / ec_voter;
    sectors_length = data.election_comittee.sectors.length;
    get_style = function(id, styles) {
      return styles.filter(function(s) {
        return s.id === id;
      })[0];
    };
    pack_root = {
      id: "all",
      name: "Registered Voter",
      value: data.registered_voter,
      power: 1,
      link: ["others"],
      children: [
        {
          id: "others",
          name: "Others",
          value: data.registered_voter - ec_voter,
          link: ["all"],
          power: 0
        }, {
          id: "ec-voters",
          name: "Voters for Election Comittee",
          value: ec_voter,
          power: ec_voter_power,
          link: data.election_comittee.sectors.map(function(s) {
            return s.id;
          }),
          children: []
        }
      ]
    };
    pack_root.children[1].children = data.election_comittee.sectors.map(function(sector) {
      return {
        id: sector.id,
        name: sector.name,
        value: sector.count,
        power: (ec_voter / sectors_length) / sector.count * ec_voter_power,
        link: ["" + sector.id + "-cm", "ec-voters"],
        children: [
          {
            id: "" + sector.id + "-cm",
            name: "Voted-in Election Comittee Members from " + sector.name,
            value: data.election_comittee.seats_per_sector,
            link: sector.id,
            power: data.registered_voter / (data.election_comittee.seats_per_sector * sectors_length)
          }, {
            id: "" + sector.id + "-non-cm",
            name: "Election Comittee Non-members from " + sector.name,
            value: sector.count - data.election_comittee.seats_per_sector,
            power: 0
          }
        ]
      };
    });
    stage_style = {
      "stage1": [
        {
          id: "all",
          size: "big",
          fill: true,
          pop_label: "fit",
          power: true
        }
      ],
      "stage2": [
        {
          id: "all",
          size: "big",
          fill: false,
          pop_label: false,
          power: false
        }, {
          id: "others",
          size: "big",
          fill: false,
          pop_label: "fit",
          power: true,
          padding: 50
        }, {
          id: "ec-voters",
          size: "big",
          fill: true,
          pop_label: "fit",
          power: true
        }
      ],
      "stage3": [
        {
          id: "all",
          size: "big",
          fill: false,
          pop_label: false
        }, {
          id: "others",
          size: "big",
          fill: false,
          pop_label: "fit",
          power: true,
          padding: 50
        }, {
          id: "ec-voters",
          size: "big",
          fill: false,
          pop_label: false
        }, {
          id: "sector-lrw",
          size: "small",
          pop_label: {
            x: -120,
            y: -45
          },
          fill: true,
          power: true,
          padding: 40
        }, {
          id: "sector-hkcpb",
          size: "small",
          pop_label: {
            x: -145,
            y: -15
          },
          fill: true,
          power: true,
          padding: 40
        }, {
          id: "sector-ftit",
          size: "small",
          pop_label: {
            x: -110,
            y: 35
          },
          fill: true,
          power: true,
          padding: 40
        }, {
          id: "sector-ehil",
          size: "small",
          pop_label: {
            x: 85,
            y: 10
          },
          fill: true,
          power: true,
          padding: 40
        }, {
          id: "sector-lrw-cm",
          size: "small",
          pop_label: false
        }, {
          id: "sector-hkcpb-cm",
          size: "small",
          pop_label: false
        }, {
          id: "sector-ftit-cm",
          size: "small",
          pop_label: false
        }, {
          id: "sector-ehil-cm",
          size: "small",
          pop_label: false
        }
      ],
      "stage4": [
        {
          id: "all",
          size: "big",
          fill: false,
          pop_label: false
        }, {
          id: "others",
          size: "big",
          fill: false,
          pop_label: false,
          power: true,
          padding: 50
        }, {
          id: "ec-voters",
          size: "big",
          fill: false,
          pop_label: false
        }, {
          id: "sector-lrw",
          size: "small",
          pop_label: false,
          fill: false
        }, {
          id: "sector-hkcpb",
          size: "small",
          pop_label: false,
          fill: false
        }, {
          id: "sector-ftit",
          size: "small",
          pop_label: false,
          fill: false
        }, {
          id: "sector-ehil",
          size: "small",
          pop_label: false,
          fill: false
        }, {
          id: "sector-lrw-cm",
          size: "small",
          pop_label: {
            x: -130,
            y: -125
          },
          power: true
        }, {
          id: "sector-hkcpb-cm",
          size: "small",
          pop_label: {
            x: -145,
            y: -55
          },
          power: true
        }, {
          id: "sector-ftit-cm",
          size: "small",
          pop_label: {
            x: -120,
            y: -5
          },
          power: true
        }, {
          id: "sector-ehil-cm",
          size: "small",
          pop_label: {
            x: 65,
            y: -45
          },
          power: true
        }
      ]
    };
    pack_g.datum(pack_root);
    pack = d3.layout.pack().size([max_size, max_size]);
    pack_data = pack.nodes(pack_root).filter(function(d) {
      return !d.hidden;
    });
    pop_nodes = pack_g.selectAll(".pop.node").data(pack_data).enter().append("g").attr("transform", function(d) {
      var cpoint, pt;
      cpoint = {
        x: max_size / 2,
        y: max_size / 2
      };
      pt = rotate(d, cpoint, -Math.PI / 2);
      d.pack_x = pt.x;
      d.pack_y = pt.y;
      return "translate(" + d.pack_x + ", " + d.pack_y + ")";
    }).attr("id", function(d) {
      return "pop-" + d.id;
    }).attr("class", function(d) {
      return "pop node " + d.id;
    });
    pop_nodes.append("circle").attr("r", function(d) {
      return d.r;
    });
    pop_labels = label_container.selectAll(".pack.label").data(pack_data).enter().append("div").attr("class", function(d) {
      return "pack label " + d.id;
    }).attr("id", function(d) {
      return "label-" + d.id;
    }).style("top", function(d) {
      return d.label_top = pack_g_offsetY + d.pack_y - d.r;
    }).style("left", function(d) {
      return d.label_left = pack_g_offsetX + d.pack_x - d.r;
    }).style("width", function(d) {
      return d.label_width = d.r * 2;
    }).style("height", function(d) {
      return d.label_height = d.r * 2;
    });
    pop_labels.append("p").html(function(d) {
      return "<strong>" + d.name + "</strong> " + (pop_format(d.value));
    });
    force_data = [];
    force_nodes = force_g.selectAll(".force.node").data(force_data);
    window.force = force = d3.layout.force().gravity(0.05).links([]).size([300, 300]).charge(0).on("tick", function(e) {
      force_nodes.each(collide(e.alpha, force_data));
      force_nodes.attr("transform", function(d) {
        return "translate(" + d.x + ", " + d.y + ")";
      });
      return force_labels.style("-webkit-transform", function(d) {
        var width_offset, x, y;
        width_offset = parseFloat(this.style.width) === 100 ? -50 + d.force_r : 0;
        x = d.x + force_g_offsetX - d.force_r + width_offset;
        y = d.y + force_g_offsetY - d.force_r;
        return "translate3d(" + x + "px, " + y + "px, 0px)";
      });
    });
    force_labels = label_container.selectAll(".power.label").data(force_data);
    cur_stage = '';
    window.update = update = function(stage) {
      var styles;
      if (stage === cur_stage) {
        return;
      }
      cur_stage = stage;
      styles = stage_style[stage];
      body.attr("class", stage);
      pop_nodes.style("opacity", 0);
      pop_labels.style("opacity", 0);
      d3.selectAll(".label-link").remove();
      force_data = [];
      styles.forEach(function(style) {
        data = pack_data.filter(function(d) {
          return d.id === style.id && style.power;
        });
        if (data.length) {
          data[0].style = style;
          force_data.push(data[0]);
        }
        pop_nodes.filter(function(d) {
          return d.id === style.id;
        }).style("opacity", 1).selectAll("circle").style("fill", function(d) {
          if (style.fill) {
            return null;
          } else {
            return "#FDFDFD";
          }
        });
        pop_labels.filter(function(d) {
          return d.id === style.id;
        }).style("width", function(d) {
          return d.label_width = typeof style.pop_label === "object" ? 100 : d.label_width;
        }).style("top", function(d) {
          if (typeof style.pop_label === "object") {
            return d.label_top + style.pop_label.y;
          } else {
            return d.label_top;
          }
        }).style("left", function(d) {
          if (typeof style.pop_label === "object") {
            return d.label_left + style.pop_label.x;
          } else {
            return d.label_left;
          }
        }).transition().duration(1000).style("opacity", function(d) {
          if (style.pop_label) {
            return 1;
          } else {
            return 0;
          }
        });
        if (typeof style.pop_label === "object") {
          return pop_labels.filter(function(d) {
            return d.id === style.id;
          }).each(function(d) {
            var label_height;
            label_height = parseFloat(d3.select(this).style("height"));
            return pack_g.append("line").datum(d).attr("class", "label-link").attr("x1", function(d) {
              return d.pack_x;
            }).attr("y1", function(d) {
              return d.pack_y;
            }).attr("x2", function(d) {
              var offset;
              offset = style.pop_label.x > 0 ? -5 : d.label_width + 5;
              return d.label_left + style.pop_label.x - pack_g_offsetX + offset;
            }).attr("y2", function(d) {
              return d.label_top + style.pop_label.y - pack_g_offsetY + label_height / 2;
            });
          });
        }
      });
      force_data.forEach((function(d) {
        var linked;
        linked = pack_data.filter(function(l) {
          return (d.link || []).indexOf(l.id) >= 0;
        });
        d.x = d3.mean(linked.map(function(l) {
          return l.x + random(-2, 2);
        }));
        d.y = d3.mean(linked.map(function(l) {
          return l.y + random(-2, 2);
        }));
        d.px = d3.mean(linked.map(function(l) {
          return l.x + random(-2, 2);
        }));
        d.py = d3.mean(linked.map(function(l) {
          return l.y + random(-2, 2);
        }));
        d.force_r = d3.mean(linked.map(function(l) {
          return l.force_r;
        }));
        linked.forEach(function(l) {
          return l.force_r = l.x = l.y = l.px = l.py = void 0;
        });
        return linked.forEach(function(l) {
          return log("setting " + d.id + " from " + l.id);
        });
      }));
      force_nodes = force_nodes.data(force_data, function(d) {
        if (d.id === "all") {
          return "others";
        } else {
          return d.id;
        }
      });
      force_nodes.attr("transform", function(d) {
        return "translate(" + d.x + ", " + d.y + ")";
      }).select("circle").transition().duration(1000).attr("r", function(d) {
        return d.force_r = power_scale(d.power);
      });
      force_nodes.exit().select("circle").transition().duration(1000).attr("r", 0).each("end", function() {
        return this.parentNode.remove();
      });
      force_nodes.enter().append("g").attr("id", function(d) {
        return "power-" + d.id;
      }).append("circle").transition().duration(1000).tween("force_r", function(d) {
        var i;
        i = d3.interpolate(d.force_r || 0, power_scale(d.power));
        return function(t) {
          var r;
          d.force_r = r = i(t);
          return this.setAttribute("r", r);
        };
      });
      force_nodes.call(force.drag);
      force_labels = label_container.selectAll(".power.label").data(force_data);
      force_labels.attr("class", function(d) {
        return "power label " + d.id;
      }).attr("id", function(d) {
        return "label-" + d.id;
      }).style("width", function(d) {
        return Math.max(power_scale(d.power) * 2, 100);
      }).style("height", function(d) {
        return power_scale(d.power) * 2;
      }).select("p").html(function(d) {
        return "<strong>" + d.name + "</strong> " + (power_format(d.power)) + "x";
      });
      force_labels.exit().transition().duration(1000).style("opacity", 0).remove();
      force_labels.enter().append("div").attr("class", function(d) {
        return "power label " + d.id;
      }).attr("id", function(d) {
        return "label-" + d.id;
      }).style("width", function(d) {
        return Math.max(power_scale(d.power) * 2, 100);
      }).style("height", function(d) {
        return power_scale(d.power) * 2;
      }).append("p").html(function(d) {
        return "<strong>" + d.name + "</strong> " + (power_format(d.power)) + "x";
      }).style("opacity", 0).transition().duration(1000).style("opacity", 1);
      return force.nodes(force_data).start();
    };
    update("stage1");
    d3.select("button#stage1").on("click", function() {
      return update("stage1");
    });
    d3.select("button#stage2").on("click", function() {
      return update("stage2");
    });
    d3.select("button#stage3").on("click", function() {
      return update("stage3");
    });
    return d3.select("button#stage4").on("click", function() {
      return update("stage4");
    });
  });

  rotate = function(point, cpoint, angle) {
    var c, s, x, y;
    s = Math.sin(angle);
    c = Math.cos(angle);
    x = point.x - cpoint.x;
    y = point.y - cpoint.y;
    return {
      x: cpoint.x + x * c - y * s,
      y: cpoint.y + x * s + y * c
    };
  };

  wrap = function(text, width) {
    return text.each(function() {
      var dy, line, lineHeight, lineNumber, tspan, word, words, x, y, _results;
      text = d3.select(this);
      words = text.text().split(/\s+/).reverse();
      word;
      line = [];
      lineNumber = 0;
      lineHeight = 1.1;
      x = text.attr("x") || 0;
      y = text.attr("y") || 0;
      dy = parseFloat(text.attr("dy")) || 0;
      tspan = text.text(null).append("tspan").attr("x", x).attr("y", y).attr("dy", dy + "em");
      _results = [];
      while ((word = words.pop())) {
        line.push(word);
        tspan.text(line.join(" "));
        if (tspan.node().getComputedTextLength() > width) {
          line.pop();
          tspan.text(line.join(" "));
          line = [word];
          _results.push(tspan = text.append("tspan").attr("x", x).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    });
  };

  random = function(min, max) {
    return Math.random() * (max - min) + min;
  };

  collide = function(alpha, force_data) {
    var quadtree;
    alpha = alpha * 0.25;
    quadtree = d3.geom.quadtree(force_data);
    return function(d) {
      var nx1, nx2, ny1, ny2, padding, r;
      padding = d.style.padding || 20;
      r = d.force_r + padding;
      nx1 = d.x - r;
      nx2 = d.x + r;
      ny1 = d.y - r;
      ny2 = d.y + r;
      return quadtree.visit(function(quad, x1, y1, x2, y2) {
        var l, x, y;
        if (quad.point && (quad.point !== d)) {
          x = d.x - quad.point.x;
          y = d.y - quad.point.y;
          l = Math.sqrt(x * x + y * y);
          r = d.force_r + quad.point.force_r + padding;
          if (l < r) {
            l = (l - r) / l * alpha;
            d.x -= x *= l;
            d.y -= y *= l;
            quad.point.x += x;
            quad.point.y += y;
          }
        }
        return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
      });
    };
  };

}).call(this);
